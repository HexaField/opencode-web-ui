{
  "pai-browser-skill": {
    "index.ts": "/**\n * Playwright Code-First Interface\n *\n * Replaces token-heavy Playwright MCP with direct code execution.\n * Savings: ~13,700 tokens (MCP) \u2192 ~50-200 tokens (per-operation)\n *\n * @example\n * const browser = new PlaywrightBrowser()\n * await browser.launch()\n * await browser.navigate('https://example.com')\n * const screenshot = await browser.screenshot()\n * await browser.close()\n */\n\nimport { chromium, firefox, webkit, type Browser, type Page, type BrowserContext } from 'playwright'\n\nexport type BrowserType = 'chromium' | 'firefox' | 'webkit'\n\nexport interface LaunchOptions {\n  browser?: BrowserType\n  headless?: boolean\n  viewport?: { width: number; height: number }\n  userAgent?: string\n}\n\nexport interface NavigateOptions {\n  timeout?: number\n  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle' | 'commit'\n}\n\nexport interface ScreenshotOptions {\n  selector?: string\n  fullPage?: boolean\n  path?: string\n  type?: 'png' | 'jpeg'\n  quality?: number\n}\n\nexport interface ClickOptions {\n  button?: 'left' | 'right' | 'middle'\n  clickCount?: number\n  delay?: number\n  timeout?: number\n}\n\nexport interface FillOptions {\n  timeout?: number\n  force?: boolean\n}\n\nexport interface ConsoleLogEntry {\n  type: string\n  text: string\n  timestamp: number\n}\n\nexport interface NetworkLogEntry {\n  type: 'request' | 'response'\n  url: string\n  method: string\n  status?: number\n  statusText?: string\n  headers?: Record<string, string>\n  resourceType?: string\n  timestamp: number\n  duration?: number\n  size?: number\n}\n\nexport interface DialogInfo {\n  type: 'alert' | 'confirm' | 'prompt' | 'beforeunload'\n  message: string\n  defaultValue?: string\n}\n\n/**\n * Main Playwright browser controller\n *\n * Provides all browser automation capabilities without MCP overhead.\n * Each method is a direct wrapper around Playwright APIs.\n */\nexport class PlaywrightBrowser {\n  private browser: Browser | null = null\n  private context: BrowserContext | null = null\n  private page: Page | null = null\n  private consoleLogs: ConsoleLogEntry[] = []\n  private networkLogs: NetworkLogEntry[] = []\n  private requestTimings: Map<string, number> = new Map()\n  private pendingDialog: DialogInfo | null = null\n  private autoHandleDialogs: boolean = false\n  private dialogResponse: string | boolean = true\n\n  /**\n   * Launch browser instance\n   */\n  async launch(options?: LaunchOptions): Promise<void> {\n    const browserType = options?.browser || 'chromium'\n    const launcher = browserType === 'firefox' ? firefox : browserType === 'webkit' ? webkit : chromium\n\n    this.browser = await launcher.launch({\n      headless: options?.headless ?? false\n    })\n\n    this.context = await this.browser.newContext({\n      viewport: options?.viewport || { width: 1280, height: 720 },\n      userAgent: options?.userAgent\n    })\n\n    this.page = await this.context.newPage()\n\n    // Attach all event listeners\n    this.attachPageListeners(this.page)\n  }\n\n  /**\n   * Ensure browser is launched\n   */\n  private ensurePage(): Page {\n    if (!this.page) {\n      throw new Error('Browser not launched. Call launch() first.')\n    }\n    return this.page\n  }\n\n  /**\n   * Attach event listeners to a page (console, network, dialog)\n   * Called when creating new pages to maintain consistent monitoring\n   */\n  private attachPageListeners(page: Page): void {\n    // Capture console logs\n    page.on('console', msg => {\n      this.consoleLogs.push({\n        type: msg.type(),\n        text: msg.text(),\n        timestamp: Date.now()\n      })\n    })\n\n    // Capture network requests\n    page.on('request', request => {\n      const timestamp = Date.now()\n      this.requestTimings.set(request.url(), timestamp)\n      this.networkLogs.push({\n        type: 'request',\n        url: request.url(),\n        method: request.method(),\n        resourceType: request.resourceType(),\n        headers: request.headers(),\n        timestamp\n      })\n    })\n\n    // Capture network responses\n    page.on('response', async response => {\n      const url = response.url()\n      const requestTime = this.requestTimings.get(url)\n      const timestamp = Date.now()\n\n      let size = 0\n      try {\n        const body = await response.body()\n        size = body.length\n      } catch {\n        // Response body not available (e.g., redirects)\n      }\n\n      this.networkLogs.push({\n        type: 'response',\n        url,\n        method: response.request().method(),\n        status: response.status(),\n        statusText: response.statusText(),\n        headers: response.headers(),\n        resourceType: response.request().resourceType(),\n        timestamp,\n        duration: requestTime ? timestamp - requestTime : undefined,\n        size\n      })\n    })\n\n    // Capture dialogs\n    page.on('dialog', async dialog => {\n      this.pendingDialog = {\n        type: dialog.type() as DialogInfo['type'],\n        message: dialog.message(),\n        defaultValue: dialog.defaultValue()\n      }\n\n      if (this.autoHandleDialogs) {\n        if (typeof this.dialogResponse === 'string') {\n          await dialog.accept(this.dialogResponse)\n        } else if (this.dialogResponse) {\n          await dialog.accept()\n        } else {\n          await dialog.dismiss()\n        }\n        this.pendingDialog = null\n      }\n    })\n  }\n\n  // ============================================\n  // NAVIGATION\n  // ============================================\n\n  /**\n   * Navigate to URL\n   */\n  async navigate(url: string, options?: NavigateOptions): Promise<void> {\n    const page = this.ensurePage()\n    await page.goto(url, {\n      timeout: options?.timeout || 30000,\n      waitUntil: options?.waitUntil || 'load'\n    })\n  }\n\n  /**\n   * Go back in browser history\n   */\n  async goBack(): Promise<void> {\n    const page = this.ensurePage()\n    await page.goBack()\n  }\n\n  /**\n   * Go forward in browser history\n   */\n  async goForward(): Promise<void> {\n    const page = this.ensurePage()\n    await page.goForward()\n  }\n\n  /**\n   * Reload current page\n   */\n  async reload(): Promise<void> {\n    const page = this.ensurePage()\n    await page.reload()\n  }\n\n  /**\n   * Get current URL\n   */\n  getUrl(): string {\n    return this.ensurePage().url()\n  }\n\n  /**\n   * Get page title\n   */\n  async getTitle(): Promise<string> {\n    return await this.ensurePage().title()\n  }\n\n  // ============================================\n  // CAPTURE\n  // ============================================\n\n  /**\n   * Take screenshot\n   *\n   * @returns Base64 encoded image or saves to path\n   */\n  async screenshot(options?: ScreenshotOptions): Promise<Buffer> {\n    const page = this.ensurePage()\n\n    if (options?.selector) {\n      const element = await page.locator(options.selector)\n      return await element.screenshot({\n        path: options?.path,\n        type: options?.type || 'png',\n        quality: options?.quality\n      })\n    }\n\n    return await page.screenshot({\n      path: options?.path,\n      fullPage: options?.fullPage || false,\n      type: options?.type || 'png',\n      quality: options?.quality\n    })\n  }\n\n  /**\n   * Get visible text content\n   */\n  async getVisibleText(selector?: string): Promise<string> {\n    const page = this.ensurePage()\n\n    if (selector) {\n      return await page.locator(selector).textContent() || ''\n    }\n\n    return await page.evaluate(() => document.body.innerText)\n  }\n\n  /**\n   * Get HTML content (with optional cleanup)\n   */\n  async getVisibleHtml(options?: {\n    selector?: string\n    removeScripts?: boolean\n    removeStyles?: boolean\n    removeComments?: boolean\n    minify?: boolean\n  }): Promise<string> {\n    const page = this.ensurePage()\n\n    let html = options?.selector\n      ? await page.locator(options.selector).innerHTML()\n      : await page.content()\n\n    if (options?.removeScripts) {\n      html = html.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n    }\n\n    if (options?.removeStyles) {\n      html = html.replace(/<style\\b[^<]*(?:(?!<\\/style>)<[^<]*)*<\\/style>/gi, '')\n    }\n\n    if (options?.removeComments) {\n      html = html.replace(/<!--[\\s\\S]*?-->/g, '')\n    }\n\n    if (options?.minify) {\n      html = html.replace(/\\s+/g, ' ').trim()\n    }\n\n    return html\n  }\n\n  /**\n   * Save page as PDF\n   */\n  async savePdf(path: string, options?: {\n    format?: 'A4' | 'Letter' | 'Legal' | 'Tabloid'\n    printBackground?: boolean\n    margin?: { top?: string; right?: string; bottom?: string; left?: string }\n  }): Promise<Buffer> {\n    const page = this.ensurePage()\n\n    return await page.pdf({\n      path,\n      format: options?.format || 'A4',\n      printBackground: options?.printBackground ?? true,\n      margin: options?.margin\n    })\n  }\n\n  // ============================================\n  // INTERACTION\n  // ============================================\n\n  /**\n   * Click element\n   */\n  async click(selector: string, options?: ClickOptions): Promise<void> {\n    const page = this.ensurePage()\n    await page.click(selector, {\n      button: options?.button,\n      clickCount: options?.clickCount,\n      delay: options?.delay,\n      timeout: options?.timeout\n    })\n  }\n\n  /**\n   * Hover over element\n   */\n  async hover(selector: string): Promise<void> {\n    const page = this.ensurePage()\n    await page.hover(selector)\n  }\n\n  /**\n   * Fill input field\n   */\n  async fill(selector: string, value: string, options?: FillOptions): Promise<void> {\n    const page = this.ensurePage()\n    await page.fill(selector, value, {\n      timeout: options?.timeout,\n      force: options?.force\n    })\n  }\n\n  /**\n   * Type text (character by character, for realistic input)\n   */\n  async type(selector: string, text: string, delay?: number): Promise<void> {\n    const page = this.ensurePage()\n    await page.locator(selector).pressSequentially(text, { delay: delay || 50 })\n  }\n\n  /**\n   * Select dropdown option\n   */\n  async select(selector: string, value: string | string[]): Promise<void> {\n    const page = this.ensurePage()\n    await page.selectOption(selector, value)\n  }\n\n  /**\n   * Press keyboard key\n   */\n  async pressKey(key: string, selector?: string): Promise<void> {\n    const page = this.ensurePage()\n\n    if (selector) {\n      await page.locator(selector).press(key)\n    } else {\n      await page.keyboard.press(key)\n    }\n  }\n\n  /**\n   * Drag element to target\n   */\n  async drag(sourceSelector: string, targetSelector: string): Promise<void> {\n    const page = this.ensurePage()\n    await page.dragAndDrop(sourceSelector, targetSelector)\n  }\n\n  /**\n   * Upload file\n   */\n  async uploadFile(selector: string, filePath: string | string[]): Promise<void> {\n    const page = this.ensurePage()\n    await page.setInputFiles(selector, filePath)\n  }\n\n  // ============================================\n  // VIEWPORT\n  // ============================================\n\n  /**\n   * Resize viewport\n   */\n  async resize(width: number, height: number): Promise<void> {\n    const page = this.ensurePage()\n    await page.setViewportSize({ width, height })\n  }\n\n  /**\n   * Set device emulation\n   */\n  async setDevice(device: string): Promise<void> {\n    const page = this.ensurePage()\n    const devices = await import('playwright').then(m => m.devices)\n    const deviceConfig = devices[device]\n\n    if (!deviceConfig) {\n      throw new Error(`Unknown device: ${device}. See Playwright devices list.`)\n    }\n\n    await page.setViewportSize(deviceConfig.viewport)\n  }\n\n  // ============================================\n  // IFRAME SUPPORT\n  // ============================================\n\n  /**\n   * Click element inside iframe\n   */\n  async iframeClick(iframeSelector: string, elementSelector: string): Promise<void> {\n    const page = this.ensurePage()\n    const frame = page.frameLocator(iframeSelector)\n    await frame.locator(elementSelector).click()\n  }\n\n  /**\n   * Fill input inside iframe\n   */\n  async iframeFill(iframeSelector: string, elementSelector: string, value: string): Promise<void> {\n    const page = this.ensurePage()\n    const frame = page.frameLocator(iframeSelector)\n    await frame.locator(elementSelector).fill(value)\n  }\n\n  // ============================================\n  // JAVASCRIPT EXECUTION\n  // ============================================\n\n  /**\n   * Execute JavaScript in page context\n   */\n  async evaluate<T>(script: string | (() => T)): Promise<T> {\n    const page = this.ensurePage()\n    return await page.evaluate(script as any)\n  }\n\n  /**\n   * Get console logs\n   */\n  getConsoleLogs(options?: {\n    type?: 'all' | 'error' | 'warning' | 'log' | 'info' | 'debug'\n    search?: string\n    limit?: number\n    clear?: boolean\n  }): ConsoleLogEntry[] {\n    let logs = [...this.consoleLogs]\n\n    if (options?.type && options.type !== 'all') {\n      logs = logs.filter(log => log.type === options.type)\n    }\n\n    if (options?.search) {\n      logs = logs.filter(log => log.text.includes(options.search!))\n    }\n\n    if (options?.limit) {\n      logs = logs.slice(-options.limit)\n    }\n\n    if (options?.clear) {\n      this.consoleLogs = []\n    }\n\n    return logs\n  }\n\n  /**\n   * Set custom user agent\n   */\n  async setUserAgent(userAgent: string): Promise<void> {\n    if (!this.context) {\n      throw new Error('Browser not launched. Call launch() first.')\n    }\n\n    // Need to create new page with new context for UA change\n    const newContext = await this.browser!.newContext({ userAgent })\n    const newPage = await newContext.newPage()\n\n    // Attach event listeners to new page\n    this.attachPageListeners(newPage)\n\n    await this.context.close()\n    this.context = newContext\n    this.page = newPage\n  }\n\n  // ============================================\n  // NETWORK MONITORING (matches browser_network_requests)\n  // ============================================\n\n  /**\n   * Get network logs (requests and responses)\n   *\n   * @example\n   * const logs = browser.getNetworkLogs({ type: 'response', status: 200 })\n   * const apiCalls = browser.getNetworkLogs({ urlPattern: /api/ })\n   * const errors = browser.getNetworkLogs({ status: [400, 401, 403, 404, 500] })\n   */\n  getNetworkLogs(options?: {\n    type?: 'request' | 'response' | 'all'\n    urlPattern?: string | RegExp\n    method?: string | string[]\n    status?: number | number[]\n    resourceType?: string | string[]\n    limit?: number\n    clear?: boolean\n  }): NetworkLogEntry[] {\n    let logs = [...this.networkLogs]\n\n    // Filter by type\n    if (options?.type && options.type !== 'all') {\n      logs = logs.filter(log => log.type === options.type)\n    }\n\n    // Filter by URL pattern\n    if (options?.urlPattern) {\n      const pattern = options.urlPattern instanceof RegExp\n        ? options.urlPattern\n        : new RegExp(options.urlPattern)\n      logs = logs.filter(log => pattern.test(log.url))\n    }\n\n    // Filter by method\n    if (options?.method) {\n      const methods = Array.isArray(options.method) ? options.method : [options.method]\n      logs = logs.filter(log => methods.includes(log.method))\n    }\n\n    // Filter by status (responses only)\n    if (options?.status) {\n      const statuses = Array.isArray(options.status) ? options.status : [options.status]\n      logs = logs.filter(log => log.status && statuses.includes(log.status))\n    }\n\n    // Filter by resource type\n    if (options?.resourceType) {\n      const types = Array.isArray(options.resourceType) ? options.resourceType : [options.resourceType]\n      logs = logs.filter(log => log.resourceType && types.includes(log.resourceType))\n    }\n\n    // Limit results\n    if (options?.limit) {\n      logs = logs.slice(-options.limit)\n    }\n\n    // Clear logs if requested\n    if (options?.clear) {\n      this.networkLogs = []\n      this.requestTimings.clear()\n    }\n\n    return logs\n  }\n\n  /**\n   * Clear all network logs\n   */\n  clearNetworkLogs(): void {\n    this.networkLogs = []\n    this.requestTimings.clear()\n  }\n\n  /**\n   * Get network summary statistics\n   */\n  getNetworkStats(): {\n    totalRequests: number\n    totalResponses: number\n    byStatus: Record<number, number>\n    byResourceType: Record<string, number>\n    totalSize: number\n    avgDuration: number\n  } {\n    const responses = this.networkLogs.filter(l => l.type === 'response')\n\n    const byStatus: Record<number, number> = {}\n    const byResourceType: Record<string, number> = {}\n    let totalSize = 0\n    let totalDuration = 0\n    let durationCount = 0\n\n    for (const log of responses) {\n      if (log.status) {\n        byStatus[log.status] = (byStatus[log.status] || 0) + 1\n      }\n      if (log.resourceType) {\n        byResourceType[log.resourceType] = (byResourceType[log.resourceType] || 0) + 1\n      }\n      totalSize += log.size || 0\n      if (log.duration) {\n        totalDuration += log.duration\n        durationCount++\n      }\n    }\n\n    return {\n      totalRequests: this.networkLogs.filter(l => l.type === 'request').length,\n      totalResponses: responses.length,\n      byStatus,\n      byResourceType,\n      totalSize,\n      avgDuration: durationCount > 0 ? totalDuration / durationCount : 0\n    }\n  }\n\n  // ============================================\n  // DIALOG HANDLING (matches browser_handle_dialog)\n  // ============================================\n\n  /**\n   * Configure automatic dialog handling\n   *\n   * @param auto - Whether to auto-handle dialogs\n   * @param response - Response for prompts (string) or confirm/alert (boolean)\n   */\n  setDialogHandler(auto: boolean, response?: string | boolean): void {\n    this.autoHandleDialogs = auto\n    this.dialogResponse = response ?? true\n  }\n\n  /**\n   * Get pending dialog (if any)\n   */\n  getPendingDialog(): DialogInfo | null {\n    return this.pendingDialog\n  }\n\n  /**\n   * Handle pending dialog manually\n   */\n  async handleDialog(action: 'accept' | 'dismiss', promptText?: string): Promise<void> {\n    const page = this.ensurePage()\n\n    // Wait briefly for dialog if not already captured\n    if (!this.pendingDialog) {\n      await this.wait(100)\n    }\n\n    if (!this.pendingDialog) {\n      throw new Error('No pending dialog to handle')\n    }\n\n    // The dialog was already stored, we need to wait for the next one if already handled\n    // This is a simplification - for more complex cases, we'd queue dialogs\n    page.once('dialog', async dialog => {\n      if (action === 'accept') {\n        await dialog.accept(promptText)\n      } else {\n        await dialog.dismiss()\n      }\n    })\n\n    this.pendingDialog = null\n  }\n\n  // ============================================\n  // WAIT FOR TEXT (matches browser_wait_for)\n  // ============================================\n\n  /**\n   * Wait for text to appear or disappear\n   */\n  async waitForText(text: string, options?: {\n    state?: 'visible' | 'hidden'\n    timeout?: number\n  }): Promise<void> {\n    const page = this.ensurePage()\n    const locator = page.getByText(text)\n\n    if (options?.state === 'hidden') {\n      await locator.waitFor({ state: 'hidden', timeout: options?.timeout })\n    } else {\n      await locator.waitFor({ state: 'visible', timeout: options?.timeout })\n    }\n  }\n\n  // ============================================\n  // TAB MANAGEMENT (matches browser_tabs)\n  // ============================================\n\n  /**\n   * Get all open tabs/pages\n   */\n  getTabs(): { url: string; title: string; index: number }[] {\n    if (!this.context) {\n      throw new Error('Browser not launched. Call launch() first.')\n    }\n\n    return this.context.pages().map((page, index) => ({\n      url: page.url(),\n      title: '', // Would need async to get title\n      index\n    }))\n  }\n\n  /**\n   * Create new tab\n   */\n  async newTab(url?: string): Promise<void> {\n    if (!this.context) {\n      throw new Error('Browser not launched. Call launch() first.')\n    }\n\n    this.page = await this.context.newPage()\n\n    // Attach all event listeners to new page\n    this.attachPageListeners(this.page)\n\n    if (url) {\n      await this.page.goto(url)\n    }\n  }\n\n  /**\n   * Switch to tab by index\n   */\n  async switchTab(index: number): Promise<void> {\n    if (!this.context) {\n      throw new Error('Browser not launched. Call launch() first.')\n    }\n\n    const pages = this.context.pages()\n    if (index < 0 || index >= pages.length) {\n      throw new Error(`Tab index ${index} out of range (0-${pages.length - 1})`)\n    }\n\n    this.page = pages[index]\n    await this.page.bringToFront()\n  }\n\n  /**\n   * Close current tab\n   */\n  async closeTab(): Promise<void> {\n    const page = this.ensurePage()\n    await page.close()\n\n    // Switch to another tab if available\n    if (this.context) {\n      const pages = this.context.pages()\n      this.page = pages.length > 0 ? pages[pages.length - 1] : null\n    }\n  }\n\n  // ============================================\n  // WAITING\n  // ============================================\n\n  /**\n   * Wait for element\n   */\n  async waitForSelector(selector: string, options?: {\n    state?: 'attached' | 'detached' | 'visible' | 'hidden'\n    timeout?: number\n  }): Promise<void> {\n    const page = this.ensurePage()\n    await page.waitForSelector(selector, {\n      state: options?.state,\n      timeout: options?.timeout\n    })\n  }\n\n  /**\n   * Wait for navigation\n   */\n  async waitForNavigation(options?: {\n    url?: string | RegExp\n    timeout?: number\n  }): Promise<void> {\n    const page = this.ensurePage()\n    await page.waitForURL(options?.url || '**/*', {\n      timeout: options?.timeout\n    })\n  }\n\n  /**\n   * Wait for network idle\n   */\n  async waitForNetworkIdle(timeout?: number): Promise<void> {\n    const page = this.ensurePage()\n    await page.waitForLoadState('networkidle', { timeout })\n  }\n\n  /**\n   * Wait fixed time (use sparingly)\n   */\n  async wait(ms: number): Promise<void> {\n    await new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  // ============================================\n  // RESPONSE MONITORING\n  // ============================================\n\n  /**\n   * Wait for specific response\n   */\n  async waitForResponse(urlPattern: string | RegExp, options?: {\n    timeout?: number\n  }): Promise<{ status: number; body: string }> {\n    const page = this.ensurePage()\n\n    const response = await page.waitForResponse(urlPattern, {\n      timeout: options?.timeout\n    })\n\n    return {\n      status: response.status(),\n      body: await response.text()\n    }\n  }\n\n  // ============================================\n  // ACCESSIBILITY\n  // ============================================\n\n  /**\n   * Get accessibility tree snapshot\n   * Uses ARIA snapshot for accessibility-focused content representation\n   */\n  async getAccessibilityTree(): Promise<string> {\n    const page = this.ensurePage()\n    // ariaSnapshot provides accessibility tree representation\n    return await page.locator(':root').ariaSnapshot()\n  }\n\n  // ============================================\n  // CLEANUP\n  // ============================================\n\n  /**\n   * Close browser\n   */\n  async close(): Promise<void> {\n    if (this.browser) {\n      await this.browser.close()\n      this.browser = null\n      this.context = null\n      this.page = null\n      this.consoleLogs = []\n      this.networkLogs = []\n      this.requestTimings.clear()\n      this.pendingDialog = null\n    }\n  }\n}\n\n// Export singleton for simple usage\nexport const browser = new PlaywrightBrowser()\n\n// Export types (using type-only export to avoid runtime issues)\nexport type { Browser, Page, BrowserContext }\n",
    "package.json": "{\n  \"name\": \"@kai/playwright\",\n  \"version\": \"2.0.0\",\n  \"description\": \"Code-first Playwright wrapper replacing token-heavy MCP\",\n  \"type\": \"module\",\n  \"main\": \"index.ts\",\n  \"scripts\": {\n    \"test\": \"bun test\"\n  },\n  \"dependencies\": {\n    \"playwright\": \"^1.49.0\"\n  },\n  \"devDependencies\": {\n    \"@types/bun\": \"^1.1.0\"\n  }\n}\n",
    "README.md": "# Browser - Code-First Interface\n\n**Replace the token-heavy Playwright MCP with direct code execution.**\n\n## Why?\n\n| Approach | Tokens | Performance |\n|----------|--------|-------------|\n| Playwright MCP | ~13,700 at load | MCP protocol overhead |\n| Code-first | ~50-200 per op | Direct Playwright API |\n| **Savings** | **99%+** | Faster execution |\n\n## Quick Start\n\n```bash\n# Install dependencies\ncd ~/.claude/skills/Browser\nbun install\n\n# Take a screenshot\nbun examples/screenshot.ts https://example.com\n\n# Verify a page loads\nbun examples/verify-page.ts https://example.com\n```\n\n## Usage\n\n### Basic\n\n```typescript\nimport { PlaywrightBrowser } from '~/.claude/skills/Browser/index.ts'\n\nconst browser = new PlaywrightBrowser()\nawait browser.launch()\nawait browser.navigate('https://example.com')\nawait browser.screenshot({ path: 'screenshot.png' })\nawait browser.close()\n```\n\n### Form Interaction\n\n```typescript\nconst browser = new PlaywrightBrowser()\nawait browser.launch({ headless: false }) // Watch it work\n\nawait browser.navigate('https://example.com/login')\nawait browser.fill('#email', 'test@example.com')\nawait browser.fill('#password', 'secret')\nawait browser.click('button[type=\"submit\"]')\nawait browser.waitForNavigation()\n\nconst title = await browser.getTitle()\nconsole.log(`Logged in! Page: ${title}`)\n\nawait browser.close()\n```\n\n### Page Verification\n\n```typescript\nconst browser = new PlaywrightBrowser()\nawait browser.launch()\n\nawait browser.navigate('https://example.com')\n\n// Check specific element exists\nawait browser.waitForSelector('h1')\nconst heading = await browser.getVisibleText('h1')\nconsole.log(`Found heading: ${heading}`)\n\n// Check for console errors\nconst errors = browser.getConsoleLogs({ type: 'error' })\nif (errors.length > 0) {\n  console.log('Console errors:', errors)\n}\n\n// Get accessibility tree (like MCP uses)\nconst a11yTree = await browser.getAccessibilityTree()\n\nawait browser.close()\n```\n\n### Device Emulation\n\n```typescript\nconst browser = new PlaywrightBrowser()\nawait browser.launch()\n\n// Emulate iPhone\nawait browser.setDevice('iPhone 14')\nawait browser.navigate('https://example.com')\nawait browser.screenshot({ path: 'mobile.png' })\n\n// Or set custom viewport\nawait browser.resize(375, 812)\n\nawait browser.close()\n```\n\n## API Reference\n\n### Constructor\n\n```typescript\nconst browser = new PlaywrightBrowser()\n```\n\n### Launch Options\n\n```typescript\nawait browser.launch({\n  browser: 'chromium', // 'chromium' | 'firefox' | 'webkit'\n  headless: true,      // false to see browser\n  viewport: { width: 1280, height: 720 },\n  userAgent: 'Custom UA'\n})\n```\n\n### Navigation\n\n| Method | Description |\n|--------|-------------|\n| `navigate(url, options?)` | Go to URL |\n| `goBack()` | Browser back |\n| `goForward()` | Browser forward |\n| `reload()` | Refresh page |\n| `getUrl()` | Current URL |\n| `getTitle()` | Page title |\n\n### Capture\n\n| Method | Description |\n|--------|-------------|\n| `screenshot(options?)` | Take screenshot |\n| `getVisibleText(selector?)` | Extract text |\n| `getVisibleHtml(options?)` | Get HTML |\n| `savePdf(path, options?)` | Export PDF |\n| `getAccessibilityTree()` | A11y snapshot |\n\n### Interaction\n\n| Method | Description |\n|--------|-------------|\n| `click(selector)` | Click element |\n| `hover(selector)` | Mouse hover |\n| `fill(selector, value)` | Fill input |\n| `type(selector, text, delay?)` | Type with delay |\n| `select(selector, value)` | Select dropdown |\n| `pressKey(key, selector?)` | Keyboard |\n| `drag(source, target)` | Drag and drop |\n| `uploadFile(selector, path)` | File upload |\n\n### Waiting\n\n| Method | Description |\n|--------|-------------|\n| `waitForSelector(selector)` | Wait for element |\n| `waitForNavigation()` | Wait for page |\n| `waitForNetworkIdle()` | Wait for idle |\n| `wait(ms)` | Fixed delay |\n\n### JavaScript\n\n| Method | Description |\n|--------|-------------|\n| `evaluate(script)` | Run JS |\n| `getConsoleLogs()` | Console output |\n| `setUserAgent(ua)` | Change UA |\n\n### iFrame\n\n| Method | Description |\n|--------|-------------|\n| `iframeClick(iframe, el)` | Click in iframe |\n| `iframeFill(iframe, el, val)` | Fill in iframe |\n\n## Token Savings\n\nThe key insight: Playwright MCP loads ~13,700 tokens of tool definitions at startup. This code-first approach:\n\n1. **Zero startup cost** - No tokens until you use a function\n2. **~50-200 tokens per operation** - Just the code you execute\n3. **Full Playwright API** - Not limited to MCP's 21 tools\n\n### Example Calculation\n\n**Scenario:** Take 5 screenshots during a session\n\n| Approach | Tokens |\n|----------|--------|\n| MCP (loaded at start) | 13,700 |\n| Code-first (5 \u00d7 ~100) | 500 |\n| **Savings** | 96.4% |\n\n## Migration from MCP\n\n### Before (MCP)\n\n```json\n{\n  \"mcpServers\": {\n    \"playwright\": {\n      \"command\": \"npx\",\n      \"args\": [\"@playwright/mcp@latest\"]\n    }\n  }\n}\n```\n\n### After (Code-First)\n\n```typescript\n// Just import and use - no MCP server needed\nimport { PlaywrightBrowser } from '~/.claude/skills/Browser/index.ts'\n\nconst browser = new PlaywrightBrowser()\n// ... use it\n```\n\n## Requirements\n\n- Bun runtime\n- Playwright (`bun add playwright`)\n\n## Related\n\n- [File-Based MCP Architecture](~/.claude/skills/CORE/SYSTEM/DOCUMENTATION/FileBasedMCPs.md)\n- [Apify Code-First](../Apify/README.md)\n- [Playwright Docs](https://playwright.dev)\n",
    "tsconfig.json": "{\n  \"compilerOptions\": {\n    \"target\": \"ESNext\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"./dist\",\n    \"declaration\": true,\n    \"types\": [\"bun-types\"]\n  },\n  \"include\": [\"*.ts\", \"tools/*.ts\", \"examples/*.ts\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n"
  }
}
